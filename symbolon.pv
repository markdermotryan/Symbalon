(*
ProVerif script to verify authentication properties of Symbalon

For a description of the protocol, see our paper
Symbalon: Privacy-preserving and Flexible Multi-device-based User Authentication
*)


(* In this version, we define the sk/pk for the authentication, and
derive secret shares from the sk. This more accurately models the
secret sharing construction in the paper *)


(* public channel *)
free c: channel.

(* private channels for sending secrets from the dealer to the authenticators *)
free pcA: channel [private].
free pcB: channel [private].
free pc1: channel [private].
free pc2: channel [private].
free pc3: channel [private].
free pc4: channel [private].
free pc5: channel [private].

(* channel for communicating the public key to the relying party *)
free pcRP: channel [private].

(* some free names available to the attacker *)
free one  : bitstring.
free two  : bitstring.
free three: bitstring.
free four : bitstring.
free five : bitstring.
free six  : bitstring.
free seven: bitstring.

event authorised(bitstring). (* the bitstring challenge has been authorised, i.e. signed by the required cohort of signers *)
event signed(channel, bitstring). (* the bitstring challenge has been signed by a regular signer denoted by the private channel pc *)
event csigned(channel, bitstring). (* the bitstring challenge has been signed by a consentful signer denoted by the private channel pc *)

(*
There are five regular key shares.
There are two "consentful" key shares.
A valid signature is made using:
- three of the five key regular shares, and also
- one of the two consent key shares
*)

type secretkey. (* secret key for authentication *)
type publickey. (* public key corresponding to secret key *)
type kshare.        (* share of secret key *)
type ckshare.        (* consentful share of secret key *)

fun pk(secretkey):publickey.  (* derive public key from a secret key *)
fun ksh1(secretkey): kshare.  (* derive the key shares from the secret key *)
fun ksh2(secretkey): kshare.
fun ksh3(secretkey): kshare.
fun ksh4(secretkey): kshare.
fun ksh5(secretkey): kshare.
fun ckshA(secretkey): ckshare.  (* derive the consentful key shares from the secret key *)
fun ckshB(secretkey): ckshare.


(* combine is the function that makes a single signature out of partial signatures *)
fun combine(bitstring, bitstring, bitstring, bitstring): bitstring.

(* sign with a key share, and with a consentful key share *)
fun sign(kshare, bitstring): bitstring.
fun csign(ckshare,bitstring): bitstring.

(* a valid combination of signatures made with shares can be verified.
"Valid" means one consentful signature and three ordinary ones *)
reduc
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh1(sk),m), sign(ksh2(sk),m), sign(ksh3(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh1(sk),m), sign(ksh2(sk),m), sign(ksh4(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh1(sk),m), sign(ksh2(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh1(sk),m), sign(ksh3(sk),m), sign(ksh4(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh1(sk),m), sign(ksh3(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh1(sk),m), sign(ksh4(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh2(sk),m), sign(ksh3(sk),m), sign(ksh4(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh2(sk),m), sign(ksh3(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh2(sk),m), sign(ksh4(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshA(sk),m), sign(ksh3(sk),m), sign(ksh4(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh1(sk),m), sign(ksh2(sk),m), sign(ksh3(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh1(sk),m), sign(ksh2(sk),m), sign(ksh4(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh1(sk),m), sign(ksh2(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh1(sk),m), sign(ksh3(sk),m), sign(ksh4(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh1(sk),m), sign(ksh3(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh1(sk),m), sign(ksh4(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh2(sk),m), sign(ksh3(sk),m), sign(ksh4(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh2(sk),m), sign(ksh3(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh2(sk),m), sign(ksh4(sk),m), sign(ksh5(sk),m))) = true;
forall sk:secretkey, m:bitstring;  verify(pk(sk), m, combine( csign(ckshB(sk),m), sign(ksh3(sk),m), sign(ksh4(sk),m), sign(ksh5(sk),m))) = true.


(* Properties to be checked
=========================== *)

(* If an access has been authorised, then some 3 of the 5 regular signers must have signed it *)

query chal:bitstring; event(authorised(chal)) ==> 
              ((event(signed(pc1, chal)) && event(signed(pc2, chal)) && event(signed(pc3, chal))) ||
               (event(signed(pc1, chal)) && event(signed(pc2, chal)) && event(signed(pc4, chal))) ||
               (event(signed(pc1, chal)) && event(signed(pc2, chal)) && event(signed(pc5, chal))) ||
               (event(signed(pc1, chal)) && event(signed(pc3, chal)) && event(signed(pc4, chal))) ||
               (event(signed(pc1, chal)) && event(signed(pc3, chal)) && event(signed(pc5, chal))) ||
               (event(signed(pc1, chal)) && event(signed(pc4, chal)) && event(signed(pc5, chal))) ||
               (event(signed(pc2, chal)) && event(signed(pc3, chal)) && event(signed(pc4, chal))) ||
               (event(signed(pc2, chal)) && event(signed(pc3, chal)) && event(signed(pc5, chal))) ||
               (event(signed(pc2, chal)) && event(signed(pc4, chal)) && event(signed(pc5, chal))) ||
               (event(signed(pc3, chal)) && event(signed(pc4, chal)) && event(signed(pc5, chal)))).


(* If an access has been authorised, then one of the two consentful signers must have signed it *)

query chal:bitstring; event(authorised(chal)) ==> (event(csigned(pcA, chal)) || event(csigned(pcB, chal))).




(* Reachability check *)
query chal:bitstring; event(authorised(chal)).


(* Definition of the protocol participants *)

let Dealer =
     new sk: secretkey;
     out(c, pk(sk));
     (* out(c, ksh1(sk)); *)
     (* uncomment line above to see an attack *)
     (  out(pcRP, pk(sk)) |
        (* let the attacker control whether a signer is enabled or not *)
        ( in(c, =one   ); out(pcA, ckshA(sk)) )|
        ( in(c, =two   ); out(pcB, ckshB(sk)) )|
        ( in(c, =three ); out(pc1, ksh1(sk))  )|
        ( in(c, =four  ); out(pc2, ksh2(sk))  )|
        ( in(c, =five  ); out(pc3, ksh3(sk))  )|
        ( in(c, =six   ); out(pc4, ksh4(sk))  )|
        ( in(c, =seven ); out(pc5, ksh5(sk))  )).

(* a regular signer has a regular key share *)
let Signer(pc: channel) =
     in(pc, k:kshare );
     in(c, mess:bitstring);
     let s = sign(k, mess) in
     event signed(pc, mess);
     out(c, s).

(* a consentful signer has both a regular key share and a consentful key share *)
let ConsentfulSigner(pc: channel, pcc:channel) =
     in(pc, k:kshare);
     in(pcc, kc:ckshare);
     in(c, mess:bitstring);
     let s = sign(k, mess) in
     let sc = csign(kc, mess) in
     event signed(pc, mess);
     event csigned(pcc, mess);
     out(c, s);
     out(c, sc).


let RelyingParty =
     in(pcRP, pubkey:publickey);
     new challenge: bitstring;
     out(c, challenge);
     in(c, s:bitstring);
     if verify(pubkey, challenge, s) = true then
     event authorised(challenge).
  

process
     (* Signers 1 and 2 are consentful signers, while 3, 4, and 5 are ordinary signers *) 
     (!Dealer) | (!ConsentfulSigner(pc1, pcA)) | (!ConsentfulSigner(pc2, pcB)) | (!Signer(pc3)) | (!Signer(pc4)) | (!Signer(pc5)) | (!RelyingParty)
